"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n0 && (0);\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  \"default\": function _default() {\n    return Router;\n  },\n  matchesMiddleware: function matchesMiddleware() {\n    return _matchesMiddleware;\n  },\n  createKey: function createKey() {\n    return _createKey;\n  }\n});\n\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\n\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\n\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\n\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\n\nvar _iserror = /*#__PURE__*/_interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\n\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\n\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\n\nvar _mitt = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\n\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\n\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\n\nvar _resolverewrites = /*#__PURE__*/_interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\n\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\n\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\n\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\n\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\n\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\n\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\n\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\n\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\n\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\n\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\n\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\n\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\n\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\n\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\n\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\n\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\n\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\n\nvar _resolvehref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\n\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\n\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\n\nfunction buildCancellationError() {\n  return Object.assign(new Error(\"Route Cancelled\"), {\n    cancelled: true\n  });\n}\n\nfunction _matchesMiddleware(_x) {\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction _matchesMiddleware2() {\n  _matchesMiddleware2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(options) {\n    var matchers, _ref6, asPathname, cleanedAs, asWithBasePathAndLocale;\n\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return Promise.resolve(options.router.pageLoader.getMiddleware());\n\n        case 2:\n          matchers = _context8.sent;\n\n          if (matchers) {\n            _context8.next = 5;\n            break;\n          }\n\n          return _context8.abrupt(\"return\", false);\n\n        case 5:\n          _ref6 = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref6.pathname; // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n\n          cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n          asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale)); // Check only path match on client. Matching \"has\" should be done on server\n          // where we can access more info such as headers, HttpOnly cookie, etc.\n\n          return _context8.abrupt(\"return\", matchers.some(function (m) {\n            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n          }));\n\n        case 9:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _matchesMiddleware2.apply(this, arguments);\n}\n\nfunction stripOrigin(url) {\n  var origin = (0, _utils.getLocationOrigin)();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  var _ref = (0, _resolvehref.resolveHref)(router, url, true),\n      _ref2 = _slicedToArray(_ref, 2),\n      resolvedHref = _ref2[0],\n      resolvedAs = _ref2[1];\n\n  var origin = (0, _utils.getLocationOrigin)();\n  var hrefWasAbsolute = resolvedHref.startsWith(origin);\n  var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n  var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n\n  if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(function (page) {\n      if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\n\nfunction getMiddlewareData(source, response, options) {\n  var nextConfig = {\n    basePath: options.router.basePath,\n    i18n: {\n      locales: options.router.locales\n    },\n    trailingSlash: Boolean(false)\n  };\n  var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n  var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n  var matchedPath = response.headers.get(\"x-matched-path\");\n\n  if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath;\n  }\n\n  if (rewriteTarget) {\n    if (rewriteTarget.startsWith(\"/\") || undefined) {\n      var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n      var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      });\n      var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n      return Promise.all([options.router.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)()]).then(function (param) {\n        var _param = _slicedToArray(param, 2),\n            pages = _param[0],\n            rewrites = _param[1].__rewrites;\n\n        var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n\n        if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n          var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n            parseData: true\n          });\n          as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n          parsedRewriteTarget.pathname = as;\n        }\n\n        if (false) { var result; } else if (!pages.includes(fsPathname)) {\n          var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname;\n          }\n        }\n\n        var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n\n        if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n          var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n          Object.assign(parsedRewriteTarget.query, matches || {});\n        }\n\n        return {\n          type: \"rewrite\",\n          parsedAs: parsedRewriteTarget,\n          resolvedHref: resolvedHref\n        };\n      });\n    }\n\n    var src = (0, _parsepath.parsePath)(source);\n    var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n      nextConfig: nextConfig,\n      parseData: true\n    })), {}, {\n      defaultLocale: options.router.defaultLocale,\n      buildId: \"\"\n    }));\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: \"\" + pathname + src.query + src.hash\n    });\n  }\n\n  var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith(\"/\")) {\n      var _src = (0, _parsepath.parsePath)(redirectTarget);\n\n      var _pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_objectSpread(_objectSpread({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(_src.pathname, {\n        nextConfig: nextConfig,\n        parseData: true\n      })), {}, {\n        defaultLocale: options.router.defaultLocale,\n        buildId: \"\"\n      }));\n\n      return Promise.resolve({\n        type: \"redirect-internal\",\n        newAs: \"\" + _pathname + _src.query + _src.hash,\n        newUrl: \"\" + _pathname + _src.query + _src.hash\n      });\n    }\n\n    return Promise.resolve({\n      type: \"redirect-external\",\n      destination: redirectTarget\n    });\n  }\n\n  return Promise.resolve({\n    type: \"next\"\n  });\n}\n\nfunction withMiddlewareEffects(_x2) {\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nfunction _withMiddlewareEffects() {\n  _withMiddlewareEffects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(options) {\n    var matches, data, effect;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          _context9.next = 2;\n          return _matchesMiddleware(options);\n\n        case 2:\n          matches = _context9.sent;\n\n          if (!(!matches || !options.fetchData)) {\n            _context9.next = 5;\n            break;\n          }\n\n          return _context9.abrupt(\"return\", null);\n\n        case 5:\n          _context9.prev = 5;\n          _context9.next = 8;\n          return options.fetchData();\n\n        case 8:\n          data = _context9.sent;\n          _context9.next = 11;\n          return getMiddlewareData(data.dataHref, data.response, options);\n\n        case 11:\n          effect = _context9.sent;\n          return _context9.abrupt(\"return\", {\n            dataHref: data.dataHref,\n            json: data.json,\n            response: data.response,\n            text: data.text,\n            cacheKey: data.cacheKey,\n            effect: effect\n          });\n\n        case 15:\n          _context9.prev = 15;\n          _context9.t0 = _context9[\"catch\"](5);\n          return _context9.abrupt(\"return\", null);\n\n        case 18:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9, null, [[5, 15]]);\n  }));\n  return _withMiddlewareEffects.apply(this, arguments);\n}\n\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\n\nfunction fetchRetry(url, attempts, options) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: \"same-origin\",\n    method: options.method || \"GET\",\n    headers: Object.assign({}, options.headers, {\n      \"x-nextjs-data\": \"1\"\n    })\n  }).then(function (response) {\n    return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n  });\n}\n\nfunction tryToParseAsJSON(text) {\n  try {\n    return JSON.parse(text);\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction fetchNextData(param) {\n  var dataHref = param.dataHref,\n      inflightCache = param.inflightCache,\n      isPrefetch = param.isPrefetch,\n      hasMiddleware = param.hasMiddleware,\n      isServerRender = param.isServerRender,\n      parseJSON = param.parseJSON,\n      persistCache = param.persistCache,\n      isBackground = param.isBackground,\n      unstable_skipClientCache = param.unstable_skipClientCache;\n\n  var _URL = new URL(dataHref, window.location.href),\n      cacheKey = _URL.href;\n\n  var _params_method;\n\n  var getData = function getData(params) {\n    return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign({}, isPrefetch ? {\n        purpose: \"prefetch\"\n      } : {}, isPrefetch && hasMiddleware ? {\n        \"x-middleware-prefetch\": \"1\"\n      } : {}),\n      method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n    }).then(function (response) {\n      if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n        return {\n          dataHref: dataHref,\n          response: response,\n          text: \"\",\n          json: {},\n          cacheKey: cacheKey\n        };\n      }\n\n      return response.text().then(function (text) {\n        if (!response.ok) {\n          /**\n          * When the data response is a redirect because of a middleware\n          * we do not consider it an error. The headers must bring the\n          * mapped location.\n          * TODO: Change the status code in the handler.\n          */\n          if (hasMiddleware && [301, 302, 307, 308].includes(response.status)) {\n            return {\n              dataHref: dataHref,\n              response: response,\n              text: text,\n              json: {},\n              cacheKey: cacheKey\n            };\n          }\n\n          if (response.status === 404) {\n            var _tryToParseAsJSON;\n\n            if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n              return {\n                dataHref: dataHref,\n                json: {\n                  notFound: SSG_DATA_NOT_FOUND\n                },\n                response: response,\n                text: text,\n                cacheKey: cacheKey\n              };\n            }\n          }\n\n          var error = new Error(\"Failed to load static props\");\n          /**\n          * We should only trigger a server-side transition if this was\n          * caused on a client-side transition. Otherwise, we'd get into\n          * an infinite loop.\n          */\n\n          if (!isServerRender) {\n            (0, _routeloader.markAssetError)(error);\n          }\n\n          throw error;\n        }\n\n        return {\n          dataHref: dataHref,\n          json: parseJSON ? tryToParseAsJSON(text) : null,\n          response: response,\n          text: text,\n          cacheKey: cacheKey\n        };\n      });\n    }).then(function (data) {\n      if (!persistCache || true || 0) {\n        delete inflightCache[cacheKey];\n      }\n\n      return data;\n    })[\"catch\"](function (err) {\n      if (!unstable_skipClientCache) {\n        delete inflightCache[cacheKey];\n      }\n\n      if ( // chrome\n      err.message === \"Failed to fetch\" || // firefox\n      err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n      err.message === \"Load failed\") {\n        (0, _routeloader.markAssetError)(err);\n      }\n\n      throw err;\n    });\n  }; // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n\n\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then(function (data) {\n      inflightCache[cacheKey] = Promise.resolve(data);\n      return data;\n    });\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = getData(isBackground ? {\n    method: \"HEAD\"\n  } : {});\n}\n\nfunction _createKey() {\n  return Math.random().toString(36).slice(2, 10);\n}\n\nfunction handleHardNavigation(param) {\n  var url = param.url,\n      router = param.router; // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n\n  if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n    throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n  }\n\n  window.location.href = url;\n}\n\nvar getCancelledHandler = function getCancelledHandler(param) {\n  var route = param.route,\n      router = param.router;\n  var cancelled = false;\n\n  var cancel = router.clc = function () {\n    cancelled = true;\n  };\n\n  var handleCancelled = function handleCancelled() {\n    if (cancelled) {\n      var error = new Error('Abort fetching component for route: \"' + route + '\"');\n      error.cancelled = true;\n      throw error;\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null;\n    }\n  };\n\n  return handleCancelled;\n};\n\nvar Router = /*#__PURE__*/function () {\n  function Router(pathname, query, as, _ref3) {\n    var _this = this;\n\n    var initialProps = _ref3.initialProps,\n        pageLoader = _ref3.pageLoader,\n        App = _ref3.App,\n        wrapApp = _ref3.wrapApp,\n        Component = _ref3.Component,\n        err = _ref3.err,\n        subscription = _ref3.subscription,\n        isFallback = _ref3.isFallback,\n        locale = _ref3.locale,\n        locales = _ref3.locales,\n        defaultLocale = _ref3.defaultLocale,\n        domainLocales = _ref3.domainLocales,\n        isPreview = _ref3.isPreview;\n\n    _classCallCheck(this, Router);\n\n    // Server Data Cache (full data requests)\n    this.sdc = {}; // Server Background Cache (HEAD requests)\n\n    this.sbc = {};\n    this.isFirstPopStateEvent = true;\n    this._key = _createKey();\n\n    this.onPopState = function (e) {\n      var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n      _this.isFirstPopStateEvent = false;\n      var state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        var _pathname2 = _this.pathname,\n            _query = _this.query;\n\n        _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n          pathname: (0, _addbasepath.addBasePath)(_pathname2),\n          query: _query\n        }), (0, _utils.getURL)());\n\n        return;\n      } // __NA is used to identify if the history entry can be handled by the app-router.\n\n\n      if (state.__NA) {\n        window.location.reload();\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      } // Safari fires popstateevent when reopening the browser.\n\n\n      if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n        return;\n      }\n\n      var forcedScroll;\n      var url = state.url,\n          as = state.as,\n          options = state.options,\n          key = state.key;\n\n      if (false) { var v; }\n\n      _this._key = key;\n\n      var _ref4 = (0, _parserelativeurl.parseRelativeUrl)(url),\n          pathname = _ref4.pathname; // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n\n      if (_this.isSsr && as === (0, _addbasepath.addBasePath)(_this.asPath) && pathname === (0, _addbasepath.addBasePath)(_this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (_this._bps && !_this._bps(state)) {\n        return;\n      }\n\n      _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n        shallow: options.shallow && _this._shallow,\n        locale: options.locale || _this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    var route = (0, _removetrailingslash.removeTrailingSlash)(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== \"/_error\") {\n      this.components[route] = {\n        Component: Component,\n        initial: true,\n        props: initialProps,\n        err: err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n\n    this.components[\"/_app\"] = {\n      Component: App,\n      styleSheets: []\n    };\n\n    if (true) {\n      var _require2 = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter/index.js\"),\n          BloomFilter = _require2.BloomFilter;\n\n      var staticFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n      var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n\n      if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n        this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n\n        this._bfl_s[\"import\"](staticFilterData);\n      }\n\n      if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n        this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n\n        this._bfl_d[\"import\"](dynamicFilterData);\n      }\n    } // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath =  false || \"\";\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n\n    if (false) {}\n\n    this.state = {\n      route: route,\n      pathname: pathname,\n      query: query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale:  false ? 0 : undefined,\n      isFallback: isFallback\n    };\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n\n    if (true) {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith(\"//\")) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        var options = {\n          locale: locale\n        };\n        var asPath = (0, _utils.getURL)();\n        this._initialMatchesMiddlewarePromise = _matchesMiddleware({\n          router: this,\n          locale: locale,\n          asPath: asPath\n        }).then(function (matches) {\n          options._shouldResolveHref = as !== pathname;\n\n          _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n            pathname: (0, _addbasepath.addBasePath)(pathname),\n            query: query\n          }), asPath, options);\n\n          return matches;\n        });\n      }\n\n      window.addEventListener(\"popstate\", this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (false) {}\n    }\n  }\n\n  _createClass(Router, [{\n    key: \"reload\",\n    value: function reload() {\n      window.location.reload();\n    }\n    /**\n    * Go back in history\n    */\n\n  }, {\n    key: \"back\",\n    value: function back() {\n      window.history.back();\n    }\n    /**\n    * Go forward in history\n    */\n\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      window.history.forward();\n    }\n    /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"push\",\n    value: function push(url, as, options) {\n      if (options === void 0) options = {};\n\n      if (false) {}\n\n      var _prepareUrlAs = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs.url;\n      as = _prepareUrlAs.as;\n      return this.change(\"pushState\", url, as, options);\n    }\n    /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(url, as, options) {\n      if (options === void 0) options = {};\n\n      var _prepareUrlAs2 = prepareUrlAs(this, url, as);\n\n      url = _prepareUrlAs2.url;\n      as = _prepareUrlAs2.as;\n      return this.change(\"replaceState\", url, as, options);\n    }\n  }, {\n    key: \"_bfl\",\n    value: function () {\n      var _bfl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(as, resolvedAs, locale, skipNavigate) {\n        var matchesBflStatic, matchesBflDynamic, _i2, _arr2, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i3, _arr3, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (false) {}\n\n              matchesBflStatic = false;\n              matchesBflDynamic = false;\n              _i2 = 0, _arr2 = [as, resolvedAs];\n\n            case 4:\n              if (!(_i2 < _arr2.length)) {\n                _context.next = 35;\n                break;\n              }\n\n              curAs = _arr2[_i2];\n\n              if (!curAs) {\n                _context.next = 32;\n                break;\n              }\n\n              asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n              asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n\n              if (!(asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname))) {\n                _context.next = 32;\n                break;\n              }\n\n              matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.has(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.has(asNoSlashLocale));\n              _i3 = 0, _arr3 = [asNoSlash, asNoSlashLocale];\n\n            case 12:\n              if (!(_i3 < _arr3.length)) {\n                _context.next = 27;\n                break;\n              }\n\n              normalizedAS = _arr3[_i3];\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              curAsParts = normalizedAS.split(\"/\");\n              i = 0;\n\n            case 16:\n              if (!(!matchesBflDynamic && i < curAsParts.length + 1)) {\n                _context.next = 24;\n                break;\n              }\n\n              currentPart = curAsParts.slice(0, i).join(\"/\");\n\n              if (!(currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.has(currentPart)))) {\n                _context.next = 21;\n                break;\n              }\n\n              matchesBflDynamic = true;\n              return _context.abrupt(\"break\", 24);\n\n            case 21:\n              i++;\n              _context.next = 16;\n              break;\n\n            case 24:\n              _i3++;\n              _context.next = 12;\n              break;\n\n            case 27:\n              if (!(matchesBflStatic || matchesBflDynamic)) {\n                _context.next = 32;\n                break;\n              }\n\n              if (!skipNavigate) {\n                _context.next = 30;\n                break;\n              }\n\n              return _context.abrupt(\"return\", true);\n\n            case 30:\n              handleHardNavigation({\n                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                router: this\n              });\n              return _context.abrupt(\"return\", new Promise(function () {}));\n\n            case 32:\n              _i2++;\n              _context.next = 4;\n              break;\n\n            case 35:\n              return _context.abrupt(\"return\", false);\n\n            case 36:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n\n      function _bfl(_x3, _x4, _x5, _x6) {\n        return _bfl2.apply(this, arguments);\n      }\n\n      return _bfl;\n    }()\n  }, {\n    key: \"change\",\n    value: function () {\n      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(method, url, as, options, forcedScroll) {\n        var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options$shallow, shallow, _options$scroll, scroll, routeProps, cleanedAs, localeChange, parsed, pathname, query, pages, rewrites, _yield$Promise$all, _yield$Promise$all2, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, rewritesResult, routeMatch, _parsedAs, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props, _self___NEXT_DATA___props_pageProps, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, _routeRegex, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs4, newUrl, newAs, notFoundRoute, _routeInfo_route, isValidShallowRoute, _options_scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props1, _self___NEXT_DATA___props_pageProps1, _routeInfo_props1, canSkipUpdating, hashRegex;\n\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if ((0, _islocalurl.isLocalURL)(url)) {\n                _context2.next = 3;\n                break;\n              }\n\n              handleHardNavigation({\n                url: url,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 3:\n              // WARNING: `_h` is an internal option for handing Next.js client-side\n              // hydration. Your app should _never_ use this property. It may change at\n              // any time without notice.\n              isQueryUpdating = options._h === 1;\n\n              if (!(!isQueryUpdating && !options.shallow)) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 7;\n              return this._bfl(as, undefined, options.locale);\n\n            case 7:\n              shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n              nextState = _objectSpread({}, this.state); // for static pages with query params in the URL we delay\n              // marking the router ready until after the query is updated\n              // or a navigation has occurred\n\n              readyStateChange = this.isReady !== true;\n              this.isReady = true;\n              isSsr = this.isSsr;\n\n              if (!isQueryUpdating) {\n                this.isSsr = false;\n              } // if a route transition is already in progress before\n              // the query updating is triggered ignore query updating\n\n\n              if (!(isQueryUpdating && this.clc)) {\n                _context2.next = 15;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", false);\n\n            case 15:\n              prevLocale = nextState.locale;\n\n              if (true) {\n                _context2.next = 28;\n                break;\n              }\n\n              nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n              if (typeof options.locale === \"undefined\") {\n                options.locale = nextState.locale;\n              }\n\n              parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);\n              localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);\n\n              if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);\n                as = (0, _formaturl.formatWithValidation)(parsedAs);\n                url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);\n              }\n\n              didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n              // moves this on its own due to the return\n\n              if (false) {}\n\n              detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n              // moves this on its own due to the return\n\n              if (false) {}\n\n              if (!didNavigate) {\n                _context2.next = 28;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 28:\n              // marking route changes as a navigation start entry\n              if (_utils.ST) {\n                performance.mark(\"routeChange\");\n              }\n\n              _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow, _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll;\n              routeProps = {\n                shallow: shallow\n              };\n\n              if (this._inFlightRoute && this.clc) {\n                if (!isSsr) {\n                  Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n                }\n\n                this.clc();\n                this.clc = null;\n              }\n\n              as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n              cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n              this._inFlightRoute = as;\n              localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n              // We should not proceed. We should only change the state.\n\n              if (!(!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange)) {\n                _context2.next = 52;\n                break;\n              }\n\n              nextState.asPath = cleanedAs;\n              Router.events.emit(\"hashChangeStart\", as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n              this.changeState(method, url, as, _objectSpread(_objectSpread({}, options), {}, {\n                scroll: false\n              }));\n\n              if (scroll) {\n                this.scrollToHash(cleanedAs);\n              }\n\n              _context2.prev = 41;\n              _context2.next = 44;\n              return this.set(nextState, this.components[nextState.route], null);\n\n            case 44:\n              _context2.next = 50;\n              break;\n\n            case 46:\n              _context2.prev = 46;\n              _context2.t0 = _context2[\"catch\"](41);\n\n              if ((0, _iserror[\"default\"])(_context2.t0) && _context2.t0.cancelled) {\n                Router.events.emit(\"routeChangeError\", _context2.t0, cleanedAs, routeProps);\n              }\n\n              throw _context2.t0;\n\n            case 50:\n              Router.events.emit(\"hashChangeComplete\", as, routeProps);\n              return _context2.abrupt(\"return\", true);\n\n            case 52:\n              parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n              pathname = parsed.pathname, query = parsed.query; // if we detected the path as app route during prefetching\n              // trigger hard navigation\n\n              if (!((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter)) {\n                _context2.next = 57;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 57:\n              _context2.prev = 57;\n              _context2.next = 60;\n              return Promise.all([this.pageLoader.getPageList(), (0, _routeloader.getClientBuildManifest)(), this.pageLoader.getMiddleware()]);\n\n            case 60:\n              _yield$Promise$all = _context2.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              pages = _yield$Promise$all2[0];\n              rewrites = _yield$Promise$all2[1].__rewrites;\n              _context2.next = 70;\n              break;\n\n            case 66:\n              _context2.prev = 66;\n              _context2.t1 = _context2[\"catch\"](57);\n              // If we fail to resolve the page list or client-build manifest, we must\n              // do a server-side transition:\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 70:\n              // If asked to change the current URL we should reload the current page\n              // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n              // We also need to set the method = replaceState always\n              // as this should not go into the history (That's how browsers work)\n              // We should compare the new asPath to the current asPath, not the url\n              if (!this.urlIsNew(cleanedAs) && !localeChange) {\n                method = \"replaceState\";\n              } // we need to resolve the as value using rewrites for dynamic SSG\n              // pages to allow building the data URL correctly\n\n\n              resolvedAs = as; // url and as should always be prefixed with basePath by this\n              // point by either next/link or router.push/replace so strip the\n              // basePath from the pathname to match the pages dir 1-to-1\n\n              pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n              isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname))); // we don't attempt resolve asPath when we need to execute\n              // middleware as the resolving will occur server-side\n\n              _context2.t2 = !options.shallow;\n\n              if (!_context2.t2) {\n                _context2.next = 81;\n                break;\n              }\n\n              _context2.next = 80;\n              return _matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: this\n              });\n\n            case 80:\n              _context2.t2 = _context2.sent;\n\n            case 81:\n              isMiddlewareMatch = _context2.t2;\n\n              if (isQueryUpdating && isMiddlewareMatch) {\n                shouldResolveHref = false;\n              }\n\n              if (!(shouldResolveHref && pathname !== \"/_error\")) {\n                _context2.next = 96;\n                break;\n              }\n\n              options._shouldResolveHref = true;\n\n              if (true) {\n                _context2.next = 94;\n                break;\n              }\n\n              rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, function (p) {\n                return resolveDynamicRoute(p, pages);\n              }, this.locales);\n\n              if (!rewritesResult.externalDest) {\n                _context2.next = 90;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", true);\n\n            case 90:\n              if (!isMiddlewareMatch) {\n                resolvedAs = rewritesResult.asPath;\n              }\n\n              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n              _context2.next = 96;\n              break;\n\n            case 94:\n              parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n              if (parsed.pathname !== pathname) {\n                pathname = parsed.pathname;\n                parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n            case 96:\n              if ((0, _islocalurl.isLocalURL)(as)) {\n                _context2.next = 101;\n                break;\n              }\n\n              if (false) {}\n\n              throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n\n            case 99:\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context2.abrupt(\"return\", false);\n\n            case 101:\n              resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              routeMatch = false;\n\n              if (!(0, _isdynamic.isDynamicRoute)(route)) {\n                _context2.next = 119;\n                break;\n              }\n\n              _parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n              asPathname = _parsedAs.pathname;\n              routeRegex = (0, _routeregex.getRouteRegex)(route);\n              routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n              shouldInterpolate = route === asPathname;\n              interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n\n              if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {\n                _context2.next = 118;\n                break;\n              }\n\n              missingParams = Object.keys(routeRegex.groups).filter(function (param) {\n                return !query[param] && !routeRegex.groups[param].optional;\n              });\n\n              if (!(missingParams.length > 0 && !isMiddlewareMatch)) {\n                _context2.next = 116;\n                break;\n              }\n\n              if (true) {\n                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n              }\n\n              throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n\n            case 116:\n              _context2.next = 119;\n              break;\n\n            case 118:\n              if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, _parsedAs, {\n                  pathname: interpolatedAs.result,\n                  query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n              } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n              }\n\n            case 119:\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeStart\", as, routeProps);\n              }\n\n              isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n              _context2.prev = 121;\n              _context2.next = 124;\n              return this.getRouteInfo({\n                route: route,\n                pathname: pathname,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite: isMiddlewareRewrite\n              });\n\n            case 124:\n              routeInfo = _context2.sent;\n\n              if (!(!isQueryUpdating && !options.shallow)) {\n                _context2.next = 128;\n                break;\n              }\n\n              _context2.next = 128;\n              return this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n\n            case 128:\n              if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n\n                if (!routeProps.shallow) {\n                  query = Object.assign({}, routeInfo.query || {}, query);\n                }\n\n                cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                  Object.keys(routeMatch).forEach(function (key) {\n                    if (routeMatch && query[key] === routeMatch[key]) {\n                      delete query[key];\n                    }\n                  });\n                }\n\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                  prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                  rewriteAs = prefixedAs;\n\n                  if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                    rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                  }\n\n                  if (false) {}\n\n                  _routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                  curRouteMatch = (0, _routematcher.getRouteMatcher)(_routeRegex)(new URL(rewriteAs, location.href).pathname);\n\n                  if (curRouteMatch) {\n                    Object.assign(query, curRouteMatch);\n                  }\n                }\n              } // If the routeInfo brings a redirect we simply apply it.\n\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 136;\n                break;\n              }\n\n              if (!(routeInfo.type === \"redirect-internal\")) {\n                _context2.next = 134;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", this.change(method, routeInfo.newUrl, routeInfo.newAs, options));\n\n            case 134:\n              handleHardNavigation({\n                url: routeInfo.destination,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 136:\n              component = routeInfo.Component;\n\n              if (component && component.unstable_scriptLoader) {\n                scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach(function (script) {\n                  (0, _script.handleClientScriptLoad)(script.props);\n                });\n              } // handle redirect on client-transition\n\n\n              if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) {\n                _context2.next = 165;\n                break;\n              }\n\n              if (!(routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT)) {\n                _context2.next = 149;\n                break;\n              }\n\n              // Use the destination from redirect without adding locale\n              options.locale = false;\n              destination = routeInfo.props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n              // client-navigation if it is falling back to hard navigation if\n              // it's not\n\n              if (!(destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false)) {\n                _context2.next = 147;\n                break;\n              }\n\n              parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n              parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n              _prepareUrlAs4 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs4.url, newAs = _prepareUrlAs4.as;\n              return _context2.abrupt(\"return\", this.change(method, newUrl, newAs, options));\n\n            case 147:\n              handleHardNavigation({\n                url: destination,\n                router: this\n              });\n              return _context2.abrupt(\"return\", new Promise(function () {}));\n\n            case 149:\n              nextState.isPreview = !!routeInfo.props.__N_PREVIEW; // handle SSG data 404\n\n              if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) {\n                _context2.next = 165;\n                break;\n              }\n\n              _context2.prev = 151;\n              _context2.next = 154;\n              return this.fetchComponent(\"/404\");\n\n            case 154:\n              notFoundRoute = \"/404\";\n              _context2.next = 160;\n              break;\n\n            case 157:\n              _context2.prev = 157;\n              _context2.t3 = _context2[\"catch\"](151);\n              notFoundRoute = \"/_error\";\n\n            case 160:\n              _context2.next = 162;\n              return this.getRouteInfo({\n                route: notFoundRoute,\n                pathname: notFoundRoute,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: {\n                  shallow: false\n                },\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                isNotFound: true\n              });\n\n            case 162:\n              routeInfo = _context2.sent;\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 165;\n                break;\n              }\n\n              throw new Error(\"Unexpected middleware effect on /404\");\n\n            case 165:\n              if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n              }\n\n              // shallow routing is only allowed for same page URL changes.\n              isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n              shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n              resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n              } : null;\n              upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll; // the new state that the router gonna set\n\n              upcomingRouterState = _objectSpread(_objectSpread({}, nextState), {}, {\n                route: route,\n                pathname: pathname,\n                query: query,\n                asPath: cleanedAs,\n                isFallback: false\n              }); // When the page being rendered is the 404 page, we should only update the\n              // query parameters. Route changes here might add the basePath when it\n              // wasn't originally present. This is also why this block is before the\n              // below `changeState` call which updates the browser's history (changing\n              // the URL).\n\n              if (!(isQueryUpdating && isErrorRoute)) {\n                _context2.next = 188;\n                break;\n              }\n\n              _context2.next = 174;\n              return this.getRouteInfo({\n                route: this.pathname,\n                pathname: this.pathname,\n                query: query,\n                as: as,\n                resolvedAs: resolvedAs,\n                routeProps: {\n                  shallow: false\n                },\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                isQueryUpdating: isQueryUpdating && !this.isFallback\n              });\n\n            case 174:\n              routeInfo = _context2.sent;\n\n              if (!(\"type\" in routeInfo)) {\n                _context2.next = 177;\n                break;\n              }\n\n              throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n\n            case 177:\n              if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n              }\n\n              _context2.prev = 178;\n              _context2.next = 181;\n              return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n            case 181:\n              _context2.next = 187;\n              break;\n\n            case 183:\n              _context2.prev = 183;\n              _context2.t4 = _context2[\"catch\"](178);\n\n              if ((0, _iserror[\"default\"])(_context2.t4) && _context2.t4.cancelled) {\n                Router.events.emit(\"routeChangeError\", _context2.t4, cleanedAs, routeProps);\n              }\n\n              throw _context2.t4;\n\n            case 187:\n              return _context2.abrupt(\"return\", true);\n\n            case 188:\n              Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n              this.changeState(method, url, as, options); // for query updates we can skip it if the state is unchanged and we don't\n              // need to scroll\n              // https://github.com/vercel/next.js/issues/37139\n\n              canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n\n              if (canSkipUpdating) {\n                _context2.next = 211;\n                break;\n              }\n\n              _context2.prev = 192;\n              _context2.next = 195;\n              return this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n\n            case 195:\n              _context2.next = 204;\n              break;\n\n            case 197:\n              _context2.prev = 197;\n              _context2.t5 = _context2[\"catch\"](192);\n\n              if (!_context2.t5.cancelled) {\n                _context2.next = 203;\n                break;\n              }\n\n              routeInfo.error = routeInfo.error || _context2.t5;\n              _context2.next = 204;\n              break;\n\n            case 203:\n              throw _context2.t5;\n\n            case 204:\n              if (!routeInfo.error) {\n                _context2.next = 207;\n                break;\n              }\n\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n              }\n\n              throw routeInfo.error;\n\n            case 207:\n              if (false) {}\n\n              if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeComplete\", as, routeProps);\n              } // A hash mark # is the optional last part of a URL\n\n\n              hashRegex = /#.+$/;\n\n              if (shouldScroll && hashRegex.test(as)) {\n                this.scrollToHash(as);\n              }\n\n            case 211:\n              return _context2.abrupt(\"return\", true);\n\n            case 214:\n              _context2.prev = 214;\n              _context2.t6 = _context2[\"catch\"](121);\n\n              if (!((0, _iserror[\"default\"])(_context2.t6) && _context2.t6.cancelled)) {\n                _context2.next = 218;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", false);\n\n            case 218:\n              throw _context2.t6;\n\n            case 219:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[41, 46], [57, 66], [121, 214], [151, 157], [178, 183], [192, 197]]);\n      }));\n\n      function change(_x7, _x8, _x9, _x10, _x11) {\n        return _change.apply(this, arguments);\n      }\n\n      return change;\n    }()\n  }, {\n    key: \"changeState\",\n    value: function changeState(method, url, as, options) {\n      if (options === void 0) options = {};\n\n      if (true) {\n        if (typeof window.history === \"undefined\") {\n          console.error(\"Warning: window.history is not available.\");\n          return;\n        }\n\n        if (typeof window.history[method] === \"undefined\") {\n          console.error(\"Warning: window.history.\" + method + \" is not available\");\n          return;\n        }\n      }\n\n      if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n        this._shallow = options.shallow;\n        window.history[method]({\n          url: url,\n          as: as,\n          options: options,\n          __N: true,\n          key: this._key = method !== \"pushState\" ? this._key : _createKey()\n        }, // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n        \"\", as);\n      }\n    }\n  }, {\n    key: \"handleRouteInfoError\",\n    value: function () {\n      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(err, pathname, query, as, routeProps, loadErrorFail) {\n        var props, _yield$this$fetchComp2, Component, styleSheets, routeInfo;\n\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              console.error(err);\n\n              if (!err.cancelled) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw err;\n\n            case 3:\n              if (!((0, _routeloader.isAssetError)(err) || loadErrorFail)) {\n                _context3.next = 7;\n                break;\n              }\n\n              Router.events.emit(\"routeChangeError\", err, as, routeProps); // If we can't load the page it could be one of following reasons\n              //  1. Page doesn't exists\n              //  2. Page does exist in a different zone\n              //  3. Internal error while loading the page\n              // So, doing a hard reload is the proper way to deal with this.\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              }); // Changing the URL doesn't block executing the current code path.\n              // So let's throw a cancellation error stop the routing logic.\n\n              throw buildCancellationError();\n\n            case 7:\n              _context3.prev = 7;\n              _context3.next = 10;\n              return this.fetchComponent(\"/_error\");\n\n            case 10:\n              _yield$this$fetchComp2 = _context3.sent;\n              Component = _yield$this$fetchComp2.page;\n              styleSheets = _yield$this$fetchComp2.styleSheets;\n              routeInfo = {\n                props: props,\n                Component: Component,\n                styleSheets: styleSheets,\n                err: err,\n                error: err\n              };\n\n              if (routeInfo.props) {\n                _context3.next = 25;\n                break;\n              }\n\n              _context3.prev = 15;\n              _context3.next = 18;\n              return this.getInitialProps(Component, {\n                err: err,\n                pathname: pathname,\n                query: query\n              });\n\n            case 18:\n              routeInfo.props = _context3.sent;\n              _context3.next = 25;\n              break;\n\n            case 21:\n              _context3.prev = 21;\n              _context3.t0 = _context3[\"catch\"](15);\n              console.error(\"Error in error page `getInitialProps`: \", _context3.t0);\n              routeInfo.props = {};\n\n            case 25:\n              return _context3.abrupt(\"return\", routeInfo);\n\n            case 28:\n              _context3.prev = 28;\n              _context3.t1 = _context3[\"catch\"](7);\n              return _context3.abrupt(\"return\", this.handleRouteInfoError((0, _iserror[\"default\"])(_context3.t1) ? _context3.t1 : new Error(_context3.t1 + \"\"), pathname, query, as, routeProps, true));\n\n            case 31:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[7, 28], [15, 21]]);\n      }));\n\n      function handleRouteInfoError(_x12, _x13, _x14, _x15, _x16, _x17) {\n        return _handleRouteInfoError.apply(this, arguments);\n      }\n\n      return handleRouteInfoError;\n    }()\n  }, {\n    key: \"getRouteInfo\",\n    value: function () {\n      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(param) {\n        var _this2 = this;\n\n        var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, resolvedRoute, pages, routeInfo, _require4, isValidElementType, wasBailedPrefetch, shouldFetchData, _yield$this$_getData2, props, cacheKey;\n\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n              /**\n              * This `route` binding can change if there's a rewrite\n              * so we keep a reference to the original requested route\n              * so we can store the cache for it and avoid re-requesting every time\n              * for shallow routing purposes.\n              */\n\n              route = requestedRoute;\n              _context5.prev = 2;\n              handleCancelled = getCancelledHandler({\n                route: route,\n                router: this\n              });\n              existingInfo = this.components[route];\n\n              if (!(routeProps.shallow && existingInfo && this.route === route)) {\n                _context5.next = 7;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", existingInfo);\n\n            case 7:\n              if (hasMiddleware) {\n                existingInfo = undefined;\n              }\n\n              cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && false ? 0 : undefined;\n              isBackground = isQueryUpdating;\n              fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                  href: (0, _formaturl.formatWithValidation)({\n                    pathname: pathname,\n                    query: query\n                  }),\n                  skipInterpolation: true,\n                  asPath: isNotFound ? \"/404\" : resolvedAs,\n                  locale: locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache: unstable_skipClientCache,\n                isBackground: isBackground\n              };\n\n              if (!(isQueryUpdating && !isMiddlewareRewrite)) {\n                _context5.next = 15;\n                break;\n              }\n\n              _context5.t0 = null;\n              _context5.next = 18;\n              break;\n\n            case 15:\n              _context5.next = 17;\n              return withMiddlewareEffects({\n                fetchData: function fetchData() {\n                  return fetchNextData(fetchNextDataParams);\n                },\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n              })[\"catch\"](function (err) {\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                  return null;\n                }\n\n                throw err;\n              });\n\n            case 17:\n              _context5.t0 = _context5.sent;\n\n            case 18:\n              data = _context5.t0;\n\n              // when rendering error routes we don't apply middleware\n              // effects\n              if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n              }\n\n              if (isQueryUpdating) {\n                if (!data) {\n                  data = {\n                    json: self.__NEXT_DATA__.props\n                  };\n                } else {\n                  data.json = self.__NEXT_DATA__.props;\n                }\n              }\n\n              handleCancelled();\n\n              if (!((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\")) {\n                _context5.next = 24;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", data.effect);\n\n            case 24:\n              if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) {\n                _context5.next = 37;\n                break;\n              }\n\n              resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n              _context5.next = 28;\n              return this.pageLoader.getPageList();\n\n            case 28:\n              pages = _context5.sent;\n\n              if (!(!isQueryUpdating || pages.includes(resolvedRoute))) {\n                _context5.next = 37;\n                break;\n              }\n\n              route = resolvedRoute;\n              pathname = data.effect.resolvedHref;\n              query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n              resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname); // Check again the cache with the new destination.\n\n              existingInfo = this.components[route];\n\n              if (!(routeProps.shallow && existingInfo && this.route === route && !hasMiddleware)) {\n                _context5.next = 37;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", _objectSpread(_objectSpread({}, existingInfo), {}, {\n                route: route\n              }));\n\n            case 37:\n              if (!(0, _isapiroute.isAPIRoute)(route)) {\n                _context5.next = 40;\n                break;\n              }\n\n              handleHardNavigation({\n                url: as,\n                router: this\n              });\n              return _context5.abrupt(\"return\", new Promise(function () {}));\n\n            case 40:\n              _context5.t1 = cachedRouteInfo;\n\n              if (_context5.t1) {\n                _context5.next = 45;\n                break;\n              }\n\n              _context5.next = 44;\n              return this.fetchComponent(route).then(function (res) {\n                return {\n                  Component: res.page,\n                  styleSheets: res.styleSheets,\n                  __N_SSG: res.mod.__N_SSG,\n                  __N_SSP: res.mod.__N_SSP\n                };\n              });\n\n            case 44:\n              _context5.t1 = _context5.sent;\n\n            case 45:\n              routeInfo = _context5.t1;\n\n              if (false) {}\n\n              _require4 = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\"), isValidElementType = _require4.isValidElementType;\n\n              if (isValidElementType(routeInfo.Component)) {\n                _context5.next = 50;\n                break;\n              }\n\n              throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n\n            case 50:\n              wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n              shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP; // For non-SSG prefetches that bailed before sending data\n              // we clear the cache to fetch full response\n\n              if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n              }\n\n              _context5.next = 55;\n              return this._getData( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n                var dataHref, fetched;\n                return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                  while (1) switch (_context4.prev = _context4.next) {\n                    case 0:\n                      if (!shouldFetchData) {\n                        _context4.next = 8;\n                        break;\n                      }\n\n                      if (!((data == null ? void 0 : data.json) && !wasBailedPrefetch)) {\n                        _context4.next = 3;\n                        break;\n                      }\n\n                      return _context4.abrupt(\"return\", {\n                        cacheKey: data.cacheKey,\n                        props: data.json\n                      });\n\n                    case 3:\n                      dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this2.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                          pathname: pathname,\n                          query: query\n                        }),\n                        asPath: resolvedAs,\n                        locale: locale\n                      });\n                      _context4.next = 6;\n                      return fetchNextData({\n                        dataHref: dataHref,\n                        isServerRender: _this2.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : _this2.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache: unstable_skipClientCache\n                      });\n\n                    case 6:\n                      fetched = _context4.sent;\n                      return _context4.abrupt(\"return\", {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                      });\n\n                    case 8:\n                      _context4.t0 = {};\n                      _context4.next = 11;\n                      return _this2.getInitialProps(routeInfo.Component, // we provide AppTree later so this needs to be `any`\n                      {\n                        pathname: pathname,\n                        query: query,\n                        asPath: as,\n                        locale: locale,\n                        locales: _this2.locales,\n                        defaultLocale: _this2.defaultLocale\n                      });\n\n                    case 11:\n                      _context4.t1 = _context4.sent;\n                      return _context4.abrupt(\"return\", {\n                        headers: _context4.t0,\n                        props: _context4.t1\n                      });\n\n                    case 13:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }, _callee4);\n              })));\n\n            case 55:\n              _yield$this$_getData2 = _context5.sent;\n              props = _yield$this$_getData2.props;\n              cacheKey = _yield$this$_getData2.cacheKey;\n\n              // Only bust the data cache for SSP routes although\n              // middleware can skip cache per request with\n              // x-middleware-cache: no-cache as well\n              if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n              } // we kick off a HEAD request in the background\n              // when a non-prefetch request is made to signal revalidation\n\n\n              if (!this.isPreview && routeInfo.__N_SSG && false && 0) {}\n\n              props.pageProps = Object.assign({}, props.pageProps);\n              routeInfo.props = props;\n              routeInfo.route = route;\n              routeInfo.query = query;\n              routeInfo.resolvedAs = resolvedAs;\n              this.components[route] = routeInfo;\n              return _context5.abrupt(\"return\", routeInfo);\n\n            case 69:\n              _context5.prev = 69;\n              _context5.t2 = _context5[\"catch\"](2);\n              return _context5.abrupt(\"return\", this.handleRouteInfoError((0, _iserror.getProperError)(_context5.t2), pathname, query, as, routeProps));\n\n            case 72:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[2, 69]]);\n      }));\n\n      function getRouteInfo(_x18) {\n        return _getRouteInfo.apply(this, arguments);\n      }\n\n      return getRouteInfo;\n    }()\n  }, {\n    key: \"set\",\n    value: function set(state, data, resetScroll) {\n      this.state = state;\n      return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n\n  }, {\n    key: \"beforePopState\",\n    value: function beforePopState(cb) {\n      this._bps = cb;\n    }\n  }, {\n    key: \"onlyAHashChange\",\n    value: function onlyAHashChange(as) {\n      if (!this.asPath) return false;\n\n      var _this$asPath$split = this.asPath.split(\"#\"),\n          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),\n          oldUrlNoHash = _this$asPath$split2[0],\n          oldHash = _this$asPath$split2[1];\n\n      var _as$split = as.split(\"#\"),\n          _as$split2 = _slicedToArray(_as$split, 2),\n          newUrlNoHash = _as$split2[0],\n          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same\n\n\n      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n        return true;\n      } // If the urls are change, there's more than a hash change\n\n\n      if (oldUrlNoHash !== newUrlNoHash) {\n        return false;\n      } // If the hash has changed, then it's a hash only change.\n      // This check is necessary to handle both the enter and\n      // leave hash === '' cases. The identity case falls through\n      // and is treated as a next reload.\n\n\n      return oldHash !== newHash;\n    }\n  }, {\n    key: \"scrollToHash\",\n    value: function scrollToHash(as) {\n      var _as$split3 = as.split(\"#\"),\n          _as$split4 = _slicedToArray(_as$split3, 2),\n          _as$split4$ = _as$split4[1],\n          hash = _as$split4$ === void 0 ? \"\" : _as$split4$; // Scroll to top if the hash is just `#` with no value or `#top`\n      // To mirror browsers\n\n\n      if (hash === \"\" || hash === \"top\") {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return window.scrollTo(0, 0);\n        });\n        return;\n      } // Decode hash to make non-latin anchor works.\n\n\n      var rawHash = decodeURIComponent(hash); // First we check if the element by id is found\n\n      var idEl = document.getElementById(rawHash);\n\n      if (idEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return idEl.scrollIntoView();\n        });\n        return;\n      } // If there's no element with the id, we check the `name` property\n      // To mirror browsers\n\n\n      var nameEl = document.getElementsByName(rawHash)[0];\n\n      if (nameEl) {\n        (0, _handlesmoothscroll.handleSmoothScroll)(function () {\n          return nameEl.scrollIntoView();\n        });\n      }\n    }\n  }, {\n    key: \"urlIsNew\",\n    value: function urlIsNew(asPath) {\n      return this.asPath !== asPath;\n    }\n    /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n\n  }, {\n    key: \"prefetch\",\n    value: function () {\n      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, asPath, options) {\n        var _this3 = this;\n\n        var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, _yield, rewritesResult, data, route;\n\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (asPath === void 0) asPath = url;\n              if (options === void 0) options = {}; // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n              if (false) {}\n\n              return _context6.abrupt(\"return\");\n\n            case 4:\n              if (!( true && (0, _isbot.isBot)(window.navigator.userAgent))) {\n                _context6.next = 6;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 6:\n              parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n              urlPathname = parsed.pathname;\n              pathname = parsed.pathname, query = parsed.query;\n              originalPathname = pathname;\n\n              if (false) {}\n\n              _context6.next = 13;\n              return this.pageLoader.getPageList();\n\n            case 13:\n              pages = _context6.sent;\n              resolvedAs = asPath;\n              locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n              _context6.next = 18;\n              return _matchesMiddleware({\n                asPath: asPath,\n                locale: locale,\n                router: this\n              });\n\n            case 18:\n              isMiddlewareMatch = _context6.sent;\n\n              if (true) {\n                _context6.next = 29;\n                break;\n              }\n\n              _context6.next = 22;\n              return (0, _routeloader.getClientBuildManifest)();\n\n            case 22:\n              _yield = _context6.sent;\n              rewrites = _yield.__rewrites;\n              rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, function (p) {\n                return resolveDynamicRoute(p, pages);\n              }, this.locales);\n\n              if (!rewritesResult.externalDest) {\n                _context6.next = 27;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 27:\n              if (!isMiddlewareMatch) {\n                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);\n              }\n\n              if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n            case 29:\n              parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n              if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n\n                if (!isMiddlewareMatch) {\n                  url = (0, _formaturl.formatWithValidation)(parsed);\n                }\n              }\n\n              if (true) {\n                _context6.next = 35;\n                break;\n              }\n\n              _context6.t0 = null;\n              _context6.next = 38;\n              break;\n\n            case 35:\n              _context6.next = 37;\n              return withMiddlewareEffects({\n                fetchData: function fetchData() {\n                  return fetchNextData({\n                    dataHref: _this3.pageLoader.getDataHref({\n                      href: (0, _formaturl.formatWithValidation)({\n                        pathname: originalPathname,\n                        query: query\n                      }),\n                      skipInterpolation: true,\n                      asPath: resolvedAs,\n                      locale: locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this3.isSsr,\n                    parseJSON: true,\n                    inflightCache: _this3.sdc,\n                    persistCache: !_this3.isPreview,\n                    isPrefetch: true\n                  });\n                },\n                asPath: asPath,\n                locale: locale,\n                router: this\n              });\n\n            case 37:\n              _context6.t0 = _context6.sent;\n\n            case 38:\n              data = _context6.t0;\n\n              /**\n              * If there was a rewrite we apply the effects of the rewrite on the\n              * current parameters for the prefetch.\n              */\n              if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                parsed.pathname = data.effect.resolvedHref;\n                pathname = data.effect.resolvedHref;\n                query = _objectSpread(_objectSpread({}, query), data.effect.parsedAs.query);\n                resolvedAs = data.effect.parsedAs.pathname;\n                url = (0, _formaturl.formatWithValidation)(parsed);\n              }\n              /**\n              * If there is a redirect to an external destination then we don't have\n              * to prefetch content as it will be unused.\n              */\n\n\n              if (!((data == null ? void 0 : data.effect.type) === \"redirect-external\")) {\n                _context6.next = 42;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 42:\n              route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n              _context6.next = 45;\n              return this._bfl(asPath, resolvedAs, options.locale, true);\n\n            case 45:\n              if (!_context6.sent) {\n                _context6.next = 47;\n                break;\n              }\n\n              this.components[urlPathname] = {\n                __appRouter: true\n              };\n\n            case 47:\n              _context6.next = 49;\n              return Promise.all([this.pageLoader._isSsg(route).then(function (isSsg) {\n                return isSsg ? fetchNextData({\n                  dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this3.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    locale: locale\n                  }),\n                  isServerRender: false,\n                  parseJSON: true,\n                  inflightCache: _this3.sdc,\n                  persistCache: !_this3.isPreview,\n                  isPrefetch: true,\n                  unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(function () {\n                  return false;\n                })[\"catch\"](function () {\n                  return false;\n                }) : false;\n              }), this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)]);\n\n            case 49:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n\n      function prefetch(_x19, _x20, _x21) {\n        return _prefetch.apply(this, arguments);\n      }\n\n      return prefetch;\n    }()\n  }, {\n    key: \"fetchComponent\",\n    value: function () {\n      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(route) {\n        var handleCancelled, componentResult;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              handleCancelled = getCancelledHandler({\n                route: route,\n                router: this\n              });\n              _context7.prev = 1;\n              _context7.next = 4;\n              return this.pageLoader.loadPage(route);\n\n            case 4:\n              componentResult = _context7.sent;\n              handleCancelled();\n              return _context7.abrupt(\"return\", componentResult);\n\n            case 9:\n              _context7.prev = 9;\n              _context7.t0 = _context7[\"catch\"](1);\n              handleCancelled();\n              throw _context7.t0;\n\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this, [[1, 9]]);\n      }));\n\n      function fetchComponent(_x22) {\n        return _fetchComponent.apply(this, arguments);\n      }\n\n      return fetchComponent;\n    }()\n  }, {\n    key: \"_getData\",\n    value: function _getData(fn) {\n      var _this4 = this;\n\n      var cancelled = false;\n\n      var cancel = function cancel() {\n        cancelled = true;\n      };\n\n      this.clc = cancel;\n      return fn().then(function (data) {\n        if (cancel === _this4.clc) {\n          _this4.clc = null;\n        }\n\n        if (cancelled) {\n          var err = new Error(\"Loading initial props cancelled\");\n          err.cancelled = true;\n          throw err;\n        }\n\n        return data;\n      });\n    }\n  }, {\n    key: \"_getFlightData\",\n    value: function _getFlightData(dataHref) {\n      // Do not cache RSC flight response since it's not a static resource\n      return fetchNextData({\n        dataHref: dataHref,\n        isServerRender: true,\n        parseJSON: false,\n        inflightCache: this.sdc,\n        persistCache: false,\n        isPrefetch: false\n      }).then(function (param) {\n        var text = param.text;\n        return {\n          data: text\n        };\n      });\n    }\n  }, {\n    key: \"getInitialProps\",\n    value: function getInitialProps(Component, ctx) {\n      var App = this.components[\"/_app\"].Component;\n\n      var AppTree = this._wrapApp(App);\n\n      ctx.AppTree = AppTree;\n      return (0, _utils.loadGetInitialProps)(App, {\n        AppTree: AppTree,\n        Component: Component,\n        router: this,\n        ctx: ctx\n      });\n    }\n  }, {\n    key: \"route\",\n    get: function get() {\n      return this.state.route;\n    }\n  }, {\n    key: \"pathname\",\n    get: function get() {\n      return this.state.pathname;\n    }\n  }, {\n    key: \"query\",\n    get: function get() {\n      return this.state.query;\n    }\n  }, {\n    key: \"asPath\",\n    get: function get() {\n      return this.state.asPath;\n    }\n  }, {\n    key: \"locale\",\n    get: function get() {\n      return this.state.locale;\n    }\n  }, {\n    key: \"isFallback\",\n    get: function get() {\n      return this.state.isFallback;\n    }\n  }, {\n    key: \"isPreview\",\n    get: function get() {\n      return this.state.isPreview;\n    }\n  }]);\n\n  return Router;\n}();\n\n(function () {\n  Router.events = (0, _mitt[\"default\"])();\n})();\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOzs7OytDQUFiLG9KOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQUEsOENBQTZDO0VBQ3pDRyxLQUFLLEVBQUU7QUFEa0MsQ0FBN0M7QUFHQSxNQUFNQyxDQUFOOztBQUtBLFNBQVNHLE9BQVQsQ0FBaUJDLE1BQWpCLEVBQXlCQyxHQUF6QixFQUE4QjtFQUMxQixLQUFJLElBQUlDLElBQVIsSUFBZ0JELEdBQWhCLEVBQW9CVCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JPLE1BQXRCLEVBQThCRSxJQUE5QixFQUFvQztJQUNwREMsVUFBVSxFQUFFLElBRHdDO0lBRXBEQyxHQUFHLEVBQUVILEdBQUcsQ0FBQ0MsSUFBRDtFQUY0QyxDQUFwQztBQUl2Qjs7QUFDREgsT0FBTyxDQUFDTCxPQUFELEVBQVU7RUFDYixXQUFTLG9CQUFXO0lBQ2hCLE9BQU9XLE1BQVA7RUFDSCxDQUhZO0VBSWJSLGlCQUFpQixFQUFFLDZCQUFXO0lBQzFCLE9BQU9BLGtCQUFQO0VBQ0gsQ0FOWTtFQU9iQyxTQUFTLEVBQUUscUJBQVc7SUFDbEIsT0FBT0EsVUFBUDtFQUNIO0FBVFksQ0FBVixDQUFQOztBQVdBLElBQU1RLHdCQUF3QixHQUFHQyxtQkFBTyxDQUFDLDRHQUFELENBQXhDOztBQUNBLElBQU1DLHlCQUF5QixHQUFHRCxtQkFBTyxDQUFDLDhHQUFELENBQXpDOztBQUNBLElBQU1FLG9CQUFvQixHQUFHRixtQkFBTyxDQUFDLGdIQUFELENBQXBDOztBQUNBLElBQU1HLFlBQVksR0FBR0gsbUJBQU8sQ0FBQyxxRkFBRCxDQUE1Qjs7QUFDQSxJQUFNSSxPQUFPLEdBQUdKLG1CQUFPLENBQUMseUVBQUQsQ0FBdkI7O0FBQ0EsSUFBTUssUUFBUSxHQUFHLGFBQWNKLHlCQUF5QixDQUFDSyxDQUExQixDQUE0Qk4sbUJBQU8sQ0FBQyx1RUFB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QUwsQ0FBVzlKLE1BQWxCO0lBQ0g7OztTQUNELGVBQWlCO01BQ2IsT0FBTyxLQUFLOEosS0FBTCxDQUFXVCxVQUFsQjtJQUNIOzs7U0FDRCxlQUFnQjtNQUNaLE9BQU8sS0FBS1MsS0FBTCxDQUFXUCxTQUFsQjtJQUNIOzs7Ozs7QUF5TEwsQ0FBQyxZQUFJO0VBQ0RoTixNQUFNLENBQUM2UCxNQUFQLEdBQWdCLENBQUMsR0FBR2xQLEtBQUssV0FBVCxHQUFoQjtBQUNILENBRkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IG51bGwsXG4gICAgY3JlYXRlS2V5OiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVyO1xuICAgIH0sXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc01pZGRsZXdhcmU7XG4gICAgfSxcbiAgICBjcmVhdGVLZXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlS2V5O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9yZW1vdmV0cmFpbGluZ3NsYXNoID0gcmVxdWlyZShcIi4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgX3JvdXRlbG9hZGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yb3V0ZS1sb2FkZXJcIik7XG5jb25zdCBfc2NyaXB0ID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9zY3JpcHRcIik7XG5jb25zdCBfaXNlcnJvciA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5fKHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvaXMtZXJyb3JcIikpO1xuY29uc3QgX2Rlbm9ybWFsaXplcGFnZXBhdGggPSByZXF1aXJlKFwiLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbmNvbnN0IF9ub3JtYWxpemVsb2NhbGVwYXRoID0gcmVxdWlyZShcIi4uL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpO1xuY29uc3QgX21pdHQgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuLi9taXR0XCIpKTtcbmNvbnN0IF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IF9pc2R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xuY29uc3QgX3BhcnNlcmVsYXRpdmV1cmwgPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmxcIik7XG5jb25zdCBfcmVzb2x2ZXJld3JpdGVzID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLXJld3JpdGVzXCIpKTtcbmNvbnN0IF9yb3V0ZW1hdGNoZXIgPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1tYXRjaGVyXCIpO1xuY29uc3QgX3JvdXRlcmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbmNvbnN0IF9mb3JtYXR1cmwgPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX2RldGVjdGRvbWFpbmxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvZGV0ZWN0LWRvbWFpbi1sb2NhbGVcIik7XG5jb25zdCBfcGFyc2VwYXRoID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcGF0aFwiKTtcbmNvbnN0IF9hZGRsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlbG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtbG9jYWxlXCIpO1xuY29uc3QgX3JlbW92ZWJhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGJhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2hhc2Jhc2VwYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgX2lzYXBpcm91dGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWFwaS1yb3V0ZVwiKTtcbmNvbnN0IF9nZXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcbmNvbnN0IF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcbmNvbnN0IF9jb21wYXJlc3RhdGVzID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcGFyZS1zdGF0ZXNcIik7XG5jb25zdCBfaXNsb2NhbHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWxvY2FsLXVybFwiKTtcbmNvbnN0IF9pc2JvdCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWJvdFwiKTtcbmNvbnN0IF9vbWl0ID0gcmVxdWlyZShcIi4vdXRpbHMvb21pdFwiKTtcbmNvbnN0IF9yZXNvbHZlaHJlZiA9IHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pbnRlcnBvbGF0ZWFzID0gcmVxdWlyZShcIi4vdXRpbHMvaW50ZXJwb2xhdGUtYXNcIik7XG5jb25zdCBfaGFuZGxlc21vb3Roc2Nyb2xsID0gcmVxdWlyZShcIi4vdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihcIlJvdXRlIENhbmNlbGxlZFwiKSwge1xuICAgICAgICBjYW5jZWxsZWQ6IHRydWVcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSk7XG4gICAgaWYgKCFtYXRjaGVycykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbigoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IGNsZWFuUGF0aG5hbWUgPT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYWdlKSAmJiAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJld3JpdGVcIik7XG4gICAgbGV0IHJld3JpdGVUYXJnZXQgPSByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1hdGNoZWQtcGF0aFwiKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiX19uZXh0X2RhdGFfY2F0Y2hhbGxcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiL19lcnJvclwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvNDA0XCIpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXdyaXRlVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZzUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWVJbmZvLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKVxuICAgICAgICAgICAgXSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSBwYXJhbTtcbiAgICAgICAgICAgICAgICBsZXQgYXMgPSAoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKSgoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoc291cmNlKS5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmV3cml0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBczogcGFyc2VkUmV3cml0ZVRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRIcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoc291cmNlKTtcbiAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgLi4uKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKHNyYy5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtZXh0ZXJuYWxcIixcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RUYXJnZXQgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJlZGlyZWN0XCIpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkocmVkaXJlY3RUYXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX2Zvcm1hdG5leHRwYXRobmFtZWluZm8uZm9ybWF0TmV4dFBhdGhuYW1lSW5mbykoe1xuICAgICAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3QtaW50ZXJuYWxcIixcbiAgICAgICAgICAgICAgICBuZXdBczogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2gsXG4gICAgICAgICAgICAgICAgbmV3VXJsOiBcIlwiICsgcGF0aG5hbWUgKyBzcmMucXVlcnkgKyBzcmMuaGFzaFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiBcIm5leHRcIlxuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gd2l0aE1pZGRsZXdhcmVFZmZlY3RzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucyk7XG4gICAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgICAgICByZXNwb25zZTogZGF0YS5yZXNwb25zZSxcbiAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgZWZmZWN0XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKipcbiAgICAgKiBUT0RPOiBSZXZpc2l0IHRoaXMgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBGb3Igbm93IHdlIHdpbGwgbm90IGNvbnNpZGVyIG1pZGRsZXdhcmUgZGF0YSBlcnJvcnMgdG8gYmUgZmF0YWwuXG4gICAgICogbWF5YmUgd2Ugc2hvdWxkIHJldmlzaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKi8gcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxSZXN0b3JhdGlvblwiIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSBcIl9fbmV4dFwiO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHt9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woXCJTU0dfREFUQV9OT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICBcIngtbmV4dGpzLWRhdGFcIjogXCIxXCJcbiAgICAgICAgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHBhcmFtKSB7XG4gICAgbGV0IHsgZGF0YUhyZWYgLCBpbmZsaWdodENhY2hlICwgaXNQcmVmZXRjaCAsIGhhc01pZGRsZXdhcmUgLCBpc1NlcnZlclJlbmRlciAsIHBhcnNlSlNPTiAsIHBlcnNpc3RDYWNoZSAsIGlzQmFja2dyb3VuZCAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gd2hlbiBza2lwcGluZyBjbGllbnQgY2FjaGUgd2Ugd2FpdCB0byB1cGRhdGVcbiAgICAvLyBpbmZsaWdodCBjYWNoZSB1bnRpbCBzdWNjZXNzZnVsIGRhdGEgcmVzcG9uc2VcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gICAgLy8gd2l0aG91dCBibG9ja2luZyBuYXZpZ2F0aW9uIHdoZW4gc3RhbGUgZGF0YSBpcyBhdmFpbGFibGVcbiAgICBpZiAodW5zdGFibGVfc2tpcENsaWVudENhY2hlICYmIHBlcnNpc3RDYWNoZSkge1xuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gUHJvbWlzZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IGdldERhdGEoaXNCYWNrZ3JvdW5kID8ge1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiXG4gICAgfSA6IHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xufVxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24ocGFyYW0pIHtcbiAgICBsZXQgeyB1cmwgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUgLCByb3V0ZXIgIH0gPSBwYXJhbTtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInB1c2hTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzXG4gICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoY3VyQXMsIFwiaHR0cDovL25cIikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc05vU2xhc2ggIT09ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5oYXMoYXNOb1NsYXNoKSkgfHwgISEoKF90aGlzX19iZmxfczEgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfczEuaGFzKGFzTm9TbGFzaExvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2hMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGFueSBzdWItcGF0aCBvZiBhcyBtYXRjaGVzIGEgZHluYW1pYyBmaWx0ZXIgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBoYXJkIG5hdmlnYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7ICFtYXRjaGVzQmZsRHluYW1pYyAmJiBpIDwgY3VyQXNQYXJ0cy5sZW5ndGggKyAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiAoKF90aGlzX19iZmxfZCA9IHRoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9kLmhhcyhjdXJyZW50UGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmwpKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIiArIGRldGVjdGVkRG9tYWluLmRvbWFpbiArICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKFwiXCIgKyAobmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gXCIvXCIgPyBcIlwiIDogYXNOb0Jhc2VQYXRoKSB8fCBcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCksXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbWV0aG9kID0gXCJyZXBsYWNlU3RhdGVcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXM7XG4gICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAvLyBiYXNlUGF0aCBmcm9tIHRoZSBwYXRobmFtZSB0byBtYXRjaCB0aGUgcGFnZXMgZGlyIDEtdG8tMVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHBhdGhuYW1lKSkgOiBwYXRobmFtZTtcbiAgICAgICAgbGV0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoXCIvXCIpICYmICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiSW50ZXJwb2xhdGluZyBocmVmXCIgOiBcIk1pc21hdGNoaW5nIGBhc2AgYW5kIGBocmVmYFwiKSArIFwiIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIFwiICsgKFwidGhlIHBhcmFtczogXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcywgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMsIF9yb3V0ZUluZm9fcHJvcHM7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJvdXRlXCIgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdC5oYW5kbGVDbGllbnRTY3JpcHRMb2FkKShzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCAsIGFzOiBuZXdBcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvNDA0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi9fZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGVJbmZvX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlSW5mb19yb3V0ZSA6IHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMS5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMxID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wczEucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiYmVmb3JlSGlzdG9yeUNoYW5nZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IGlzUXVlcnlVcGRhdGluZyAmJiAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJiAhcmVhZHlTdGF0ZUNoYW5nZSAmJiAhbG9jYWxlQ2hhbmdlICYmICgwLCBfY29tcGFyZXN0YXRlcy5jb21wYXJlUm91dGVyU3RhdGVzKSh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0gYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi9fZXJyb3JcIik7XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiBcIiwgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzZXJyb3IuZGVmYXVsdCkocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyBcIlwiKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0Um91dGVJbmZvKHBhcmFtKSB7XG4gICAgICAgIGxldCB7IHJvdXRlOiByZXF1ZXN0ZWRSb3V0ZSAsIHBhdGhuYW1lICwgcXVlcnkgLCBhcyAsIHJlc29sdmVkQXMgLCByb3V0ZVByb3BzICwgbG9jYWxlICwgaGFzTWlkZGxld2FyZSAsIGlzUHJldmlldyAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAsIGlzUXVlcnlVcGRhdGluZyAsIGlzTWlkZGxld2FyZVJld3JpdGUgLCBpc05vdEZvdW5kICB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgfHwgcGF0aG5hbWUgPT09IFwiLzQwNFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBwYXRobmFtZSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX3Jlc3BvbnNlID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLXNraXBcIik7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzICwgY2FjaGVLZXkgIH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjXG4gICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSBcIlwiXSA9IGFzLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+d2luZG93LnNjcm9sbFRvKDAsIDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PmlkRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gYXN5bmMgcHJlZmV0Y2godXJsLCBhc1BhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGFzUGF0aCA9PT0gdm9pZCAwKSBhc1BhdGggPSB1cmw7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgLy8gUHJlZmV0Y2ggaXMgbm90IHN1cHBvcnRlZCBpbiBkZXZlbG9wbWVudCBtb2RlIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBvbi1kZW1hbmQtZW50cmllc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgKDAsIF9pc2JvdC5pc0JvdCkod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAgICAgICAvLyBsaW5rcyB2aWEgdGhlIGVxdWl2YWxlbnQgb2YgYSBoYXJkIG5hdmlnYXRpb24gYW5kIGhlbmNlIG5ldmVyIHV0aWxpemUgdGhlc2VcbiAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICBjb25zdCB1cmxQYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IGF3YWl0ICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSk7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNQYXRoLCB0aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGFyc2VkLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksICgwLCBfcm91dGVtYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHBhcnNlZC5wYXRobmFtZSkpKCgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXNQYXRoKS5wYXRobmFtZSkgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCA9PT0gXCJzdHJpY3RcIiA/IG51bGwgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogb3JpZ2luYWxQYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZWRpcmVjdC1leHRlcm5hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xuICAgICAgICAgICAgICAgIF9fYXBwUm91dGVyOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/IFwibG9hZFBhZ2VcIiA6IFwicHJlZmV0Y2hcIl0ocm91dGUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgdGV4dCAgfSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgIH0gPSB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXTtcbiAgICAgICAgY29uc3QgQXBwVHJlZSA9IHRoaXMuX3dyYXBBcHAoQXBwKTtcbiAgICAgICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlO1xuICAgICAgICByZXR1cm4gKDAsIF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsIHtcbiAgICAgICAgICAgIEFwcFRyZWUsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICBjdHhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCByb3V0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGU7XG4gICAgfVxuICAgIGdldCBwYXRobmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWU7XG4gICAgfVxuICAgIGdldCBxdWVyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnk7XG4gICAgfVxuICAgIGdldCBhc1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmFzUGF0aDtcbiAgICB9XG4gICAgZ2V0IGxvY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUubG9jYWxlO1xuICAgIH1cbiAgICBnZXQgaXNGYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNGYWxsYmFjaztcbiAgICB9XG4gICAgZ2V0IGlzUHJldmlldygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXRobmFtZSwgcXVlcnksIGFzLCB7IGluaXRpYWxQcm9wcyAsIHBhZ2VMb2FkZXIgLCBBcHAgLCB3cmFwQXBwICwgQ29tcG9uZW50ICwgZXJyICwgc3Vic2NyaXB0aW9uICwgaXNGYWxsYmFjayAsIGxvY2FsZSAsIGxvY2FsZXMgLCBkZWZhdWx0TG9jYWxlICwgZG9tYWluTG9jYWxlcyAsIGlzUHJldmlldyAgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzLmdldFVSTCkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJiB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiYgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl0gPSB7XG4gICAgICAgICAgICBDb21wb25lbnQ6IEFwcCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2Jsb29tLWZpbHRlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUjtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVI7XG4gICAgICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLnNpemUsIHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGR5bmFtaWNGaWx0ZXJEYXRhLmhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKGR5bmFtaWNGaWx0ZXJEYXRhLnNpemUsIGR5bmFtaWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXNQYXRoOiBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXMsXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRoID0gKDAsIF91dGlscy5nZXRVUkwpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4oKCk9PntcbiAgICBSb3V0ZXIuZXZlbnRzID0gKDAsIF9taXR0LmRlZmF1bHQpKCk7XG59KSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwibWF0Y2hlc01pZGRsZXdhcmUiLCJjcmVhdGVLZXkiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiX3JvdXRlbG9hZGVyIiwiX3NjcmlwdCIsIl9pc2Vycm9yIiwiXyIsIl9kZW5vcm1hbGl6ZXBhZ2VwYXRoIiwiX25vcm1hbGl6ZWxvY2FsZXBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc2R5bmFtaWMiLCJfcGFyc2VyZWxhdGl2ZXVybCIsIl9yZXNvbHZlcmV3cml0ZXMiLCJfcm91dGVtYXRjaGVyIiwiX3JvdXRlcmVnZXgiLCJfZm9ybWF0dXJsIiwiX2RldGVjdGRvbWFpbmxvY2FsZSIsIl9wYXJzZXBhdGgiLCJfYWRkbG9jYWxlIiwiX3JlbW92ZWxvY2FsZSIsIl9yZW1vdmViYXNlcGF0aCIsIl9hZGRiYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9pc2FwaXJvdXRlIiwiX2dldG5leHRwYXRobmFtZWluZm8iLCJfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyIsIl9jb21wYXJlc3RhdGVzIiwiX2lzbG9jYWx1cmwiLCJfaXNib3QiLCJfb21pdCIsIl9yZXNvbHZlaHJlZiIsIl9pbnRlcnBvbGF0ZWFzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJvdXRlciIsInBhZ2VMb2FkZXIiLCJnZXRNaWRkbGV3YXJlIiwibWF0Y2hlcnMiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJhc1BhdGhuYW1lIiwicGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwicGFyYW0iLCJyZXdyaXRlcyIsIl9fcmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZmV0Y2hEYXRhIiwiZGF0YSIsImRhdGFIcmVmIiwiZWZmZWN0IiwianNvbiIsInRleHQiLCJjYWNoZUtleSIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJmZXRjaE5leHREYXRhIiwiaW5mbGlnaHRDYWNoZSIsImlzUHJlZmV0Y2giLCJoYXNNaWRkbGV3YXJlIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXJzZUpTT04iLCJwZXJzaXN0Q2FjaGUiLCJpc0JhY2tncm91bmQiLCJ1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUiLCJVUkwiLCJsb2NhdGlvbiIsImhyZWYiLCJfcGFyYW1zX21ldGhvZCIsImdldERhdGEiLCJwYXJhbXMiLCJwdXJwb3NlIiwiX3RyeVRvUGFyc2VBc0pTT04iLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiZXJyIiwibWVzc2FnZSIsInVuZGVmaW5lZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJpbml0aWFsUHJvcHMiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJzZGMiLCJzYmMiLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIl9rZXkiLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsImdldFVSTCIsIl9fTkEiLCJyZWxvYWQiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJrZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0SXRlbSIsImlzU3NyIiwiX2JwcyIsImNoYW5nZSIsInNoYWxsb3ciLCJfc2hhbGxvdyIsIl9oIiwiY29tcG9uZW50cyIsImluaXRpYWwiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwic3R5bGVTaGVldHMiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCIsIkJsb29tRmlsdGVyIiwic3RhdGljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSIiwiZHluYW1pY0ZpbHRlckRhdGEiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiIsImhhc2hlcyIsIl9iZmxfcyIsInNpemUiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsImhhcyIsIl90aGlzX19iZmxfczEiLCJub3JtYWxpemVkQVMiLCJjdXJBc1BhcnRzIiwic3BsaXQiLCJpIiwiY3VycmVudFBhcnQiLCJqb2luIiwiX3RoaXNfX2JmbF9kIiwiaXNMb2NhbFVSTCIsImlzUXVlcnlVcGRhdGluZyIsIl9iZmwiLCJzaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2TG9jYWxlIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwiZGlkTmF2aWdhdGUiLCJfdGhpc19sb2NhbGVzIiwiZGV0ZWN0ZWREb21haW4iLCJkb21haW4iLCJhc05vQmFzZVBhdGgiLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwiX2luRmxpZ2h0Um91dGUiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwibG9jYWxlQ2hhbmdlIiwib25seUFIYXNoQ2hhbmdlIiwic2Nyb2xsVG9IYXNoIiwic2V0IiwicGFyc2VkIiwiX3RoaXNfY29tcG9uZW50c19wYXRobmFtZSIsIl9fYXBwUm91dGVyIiwidXJsSXNOZXciLCJwYXJzZWRBc1BhdGhuYW1lIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJwIiwiZXh0ZXJuYWxEZXN0Iiwicm91dGVNYXRjaCIsInJvdXRlUmVnZXgiLCJzaG91bGRJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsIm1pc3NpbmdQYXJhbXMiLCJrZXlzIiwiZ3JvdXBzIiwiZmlsdGVyIiwib3B0aW9uYWwiLCJjb25zb2xlIiwid2FybiIsIm9taXQiLCJpc0Vycm9yUm91dGUiLCJnZXRSb3V0ZUluZm8iLCJyb3V0ZUluZm8iLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJmb3JFYWNoIiwicHJlZml4ZWRBcyIsInJld3JpdGVBcyIsImxvY2FsZVJlc3VsdCIsImN1clJvdXRlTWF0Y2giLCJjb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJmZXRjaENvbXBvbmVudCIsIm5vdEZvdW5kUm91dGUiLCJpc05vdEZvdW5kIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzIiwic3RhdHVzQ29kZSIsIl9yb3V0ZUluZm9fcHJvcHMiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX3JvdXRlSW5mb19yb3V0ZSIsInNob3VsZFNjcm9sbCIsIl9vcHRpb25zX3Njcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSIsIl9yb3V0ZUluZm9fcHJvcHMxIiwiY2FuU2tpcFVwZGF0aW5nIiwiY29tcGFyZVJvdXRlclN0YXRlcyIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwibGFuZyIsImhhc2hSZWdleCIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsInJlcXVlc3RlZFJvdXRlIiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJfZGF0YV9lZmZlY3QiLCJfZGF0YV9lZmZlY3QxIiwiX2RhdGFfZWZmZWN0MiIsInJlc29sdmVkUm91dGUiLCJpc0FQSVJvdXRlIiwicmVzIiwibW9kIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJfZGF0YV9yZXNwb25zZSIsInNob3VsZEZldGNoRGF0YSIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhdGhuYW1lIiwib3JpZ2luYWxQYXRobmFtZSIsIl9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIIiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImxvYWRQYWdlIiwiY29tcG9uZW50UmVzdWx0IiwiZm4iLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});